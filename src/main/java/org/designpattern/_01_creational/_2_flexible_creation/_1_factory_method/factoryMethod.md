# Factory Method 디자인 패턴

# 01. 가장 실질적인 코드와 이를 활용하는 실제 사례

## 1. 구현 코드
[code](code)

## 2. 사용 사례
### 공통점 : 한 종류의 객체, 다양하게 생성


- 데이터베이스 연결 
  - 클라이언트가 데이터베이스 타입에 따른 구체적 구현 몰라도, 팩토리 통해 연결객체 생성 
- 메시지 파서 (Message Parsing)
  - 메시지 형식마다 다른 파서를 생성하되, 클라이언트는 형식의 세부사항을 몰라도 됨 



# 02.  패턴이 가지는 강점과 약점

## 1. 장단점
### 장점 4
#### 1. 객체 생성의 유연성
    - 객체 생성 로직을 하위 클래스에서 정의할 수 있어, 새로운 객체 유형을 쉽게 추가 가능 
#### 2. 결합도 감소
    - 클라이언트가 구체적인 클래스에 의존하지 않고, 추상 클래스나 인터페이스에 의존
#### 3. 코드 재사용성 증가
    - 공통 객체 생성 로직을 상위 클래스에 정의하고, 하위 클래스에서 필요한 부분만 재정의
#### 4. 확장성 향상
    - 새로운 객체 유형이 추가될 때, 기존 코드에 영향을 주지 않고 하위 클래스를 통해 구현

### 단점 4
#### 1. 복잡성 증가
    - 간단한 객체 생성에도 추상 클래스와 하위 클래스를 추가해야
#### 2. 하위 클래스 의존 
    - 객체 생성 로직이 하위 클래스에 의존하므로, 하위 클래스를 추가/변경하는 작업이 빈번해질 경우 유지보수가 복잡
    - 하위 클래스의 수가 많아지면 생성 로직을 추적하기 어려움.
#### 3. 추가 코드 작성 필요
    - 새로운 객체 유형을 추가할 때, 추가 클래스와 메서드를 작성해야 함
#### 4. 동일한 객체 생성 시 비효율성
    - 반복적으로 동일한 객체를 생성해야 할 경우 Singleton 패턴이나 캐싱과의 결합이 필요.


# 03. 동작 방식 이해 후, 이를 뒷받침하는 구조와 정의

## 1. 동작 원리
- 객체 생성에 대한 책임을 구체적인 클래스가 아닌 상위 클래스(추상 클래스 또는 인터페이스)에서 정의
- 하위 클래스에서 구체적으로 구현
- 클라이언트는 팩토리 메서드를 호출해 객체를 생성하며, 구체적인 생성 클래스에 의존하지 않음 



## 2. 구조
````
<<Interface>>                                <<Concrete Product>>
+--------------------+                     +-----------------------+
|     Product        |<-------------------||   ConcreteProduct     |
+--------------------+                     +-----------------------+
           ^
           |       
           | 
           | 
<<Abstract>>                                  <<Concrete Creator>>
+--------------------+                     +-----------------------+
|     Creator        |<-------------------|    ConcreteCreator    |
+--------------------+                     +-----------------------+
| + FactoryMethod()  |                     | + FactoryMethod()     |
| + AnOperation()    |                     | // create new object  |
+--------------------+                     +-----------------------+
````
### 1) Product (추상 제품)
- 생성할 객체의 공통 인터페이스를 정의

### 2) ConcreteProduct (구체 제품)
- Product를 구현하며, 팩토리 메서드를 통해 생성되는 실제 객체

### 3) Creator (추상 크리에이터)
- 객체 생성을 위한 팩토리 메서드(FactoryMethod)를 선언
- 구체적인 객체 생성은 하위 클래스에서 구현되며, 클라이언트는 이를 호출하여 객체를 생성

### 4) ConcreteCreator (구체 크리에이터)
- Creator를 구현하며, FactoryMethod를 통해 구체적인 Product 객체를 생성




## 3. 정의
- 객체 생성 로직을 서브클래스에 위임, 객체 생성 코드를 클라이언트 코드와 분리하는 패턴
- 객체 생성을 위한 팩토리 메서드를 사용, 구체적인 생성 클래스는 하위 클래스에서 정의



## 4. 목적
### 1) 객체 생성의 책임 분리
### 2) 확장성 증가
### 3) 코드 재사용성





# 04.  패턴이 적합한 상황과 선택의 이유를 다른 패턴과 비교하며 학습

## 1. 적용 조건
- 이 패턴이 적합한 상황은 언제인가요?
- 적용하기 위한 전제 조건이나 특정 문제 유형을 설명하세요.

## 2. 비교와 선택
- 이 패턴을 다른 유사한 패턴과 비교하세요.
  - 예: Factory Method와 Abstract Factory의 차이.
- 어떤 상황에서 이 패턴을 선택해야 하는지 설명하세요.


## 3. 관련된 패턴
- 이 패턴과 함께 자주 사용되는 패턴은 무엇인가요?
  - 예: Decorator 패턴은 Strategy 패턴과 함께 사용되기도 함.
- 다른 패턴과의 관계를 설명하세요.
  - 예: 이 패턴이 다른 패턴의 일부로 사용되거나, 서로 보완적 역할을 하는 경우.


# 04.  패턴을 실제로 사용할 때 발생할 수 있는 문제와 실전 사례

## 1. 오해와 주의점
- 이 패턴과 관련된 일반적인 오해는 무엇인가요?
  - 예: Singleton은 무조건 하나의 인스턴스만 생성된다는 오해.
- 패턴을 잘못 사용할 때 발생할 수 있는 문제를 설명하세요.
  - 예: 잘못된 Singleton 구현은 멀티스레드 환경에서 동기화 문제를 유발.



## 2. 프로젝트 경험
- 이 패턴을 실제 프로젝트에서 사용한 경험이 있나요?
- 사용했던 사례와 그 결과를 기록하세요.
  - 프로젝트 이름, 패턴 적용 이유, 결과 등.



## 3. 확장성
- 이 패턴을 확장하거나 변형하는 방법은 무엇인가요?
  - 예: Prototype 패턴에서 깊은 복사와 얕은 복사를 선택적으로 구현.
- 확장 가능한 구조로 설계하기 위한 팁이나 예시를 작성하세요.



## 4. 비용
- 이 패턴을 사용하는 데 드는 비용(성능, 코드 복잡도 등)을 분석하세요.
  - 예: Decorator는 클래스 수가 증가하여 코드가 복잡해질 수 있음.
- 효율적으로 사용할 수 있는 방법을 설명하세요.
  - 예: 필요 이상의 Decorator를 사용하지 않고 핵심 기능에만 적용.