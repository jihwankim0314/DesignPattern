# Prototype 디자인 패턴

# 01. 가장 실질적인 코드와 이를 활용하는 실제 사례

## 1. 구현 코드
[code](code)

## 2. 사용 사례
### 공통점 : 반복 작업 지양 / 초기화 비용 감소 / 필요한 것만 수정 

- 문서 템플릿 
  - 문서 별 양식이 동일할 경우, 양식을 템플릿 화 -> 반복 사용 가능 
- 공통 대다수, 차이 적은 요소 대량 생산 
  기존의 것을 복사하여 필요한 요소만 수정

# 02.  패턴이 가지는 강점과 약점

## 1. 장단점
### 장점
#### 1. 객체 생성 비용 절감
    -  복잡한 초기화 작업이나 높은 생성 비용을 줄임 
#### 2.유연한 확장성
    - 새로운 유형의 객체를 Prototype으로 추가한 후, 복사하여 사용

### 단점
#### 1.복제의 복잡성
    - 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)를 명확히 구분하지 않을 시 문제
#### 2.객체 상태 관리의 어려움
    - 독립적으로 상태를 변경할 수 있으므로, 상태 추적 및 관리가 복잡해질 수 있음
#### 3. 메모리 및 성능 문제
    - 모든 필드와 참조 객체를 재귀적으로 복사하므로 메모리와 CPU 비용이 증가 가능 


# 03. 동작 방식 이해 후, 이를 뒷받침하는 구조와 정의

## 1. 동작 원리
- 기존 객체를 복제(Clone)하여 새로운 객체를 생성


## 2. 구조 - 2
````
<<interface or abstract>>               <<Concrete Class>>
+-----------------------+             +---------------------+
|      Prototype        |<-----------|   ConcretePrototype |
+-----------------------+             +---------------------+
| + clone()  :  Object  |             | + clone() : Object  |
+-----------------------+             +---------------------+

------------------------- 여기까지가 필수 ----------------------

               ^
               |
+---------------------+
|      Client         |
+---------------------+
| - prototype : Object|
| + createClone()     |
+---------------------+
````
### 1)Prototype (인터페이스 또는 추상 클래스)
- 객체 복제 메서드인 clone()을 선언
- 구체적인 복제 로직은 구현 클래스에서 정의

### 2) ConcretePrototype (구체적 구현 클래스)
- [Prototype을 구현하거나 확장]하여, clone() 메서드를 통해 객체 복제를 제공
  - 복제 과정에서 내부 상태를 복사(얕은 복사 or 깊은 복사).

### cf) Client (사용자)
- Prototype 객체를 사용하여 복제를 요청하고, 새로운 객체를 생성
- Prototype의 구체적인 구현 클래스에 의존하지 않으므로, 유연성과 확장성이 높음

## 3. 정의
-  객체를 새로 생성하는 대신 [기존 객체를 복제하여 새로운 객체를 생성]하는 디자인 패턴
- [인터페이스나 추상 클래스]를 통해 [복제 계약을 정의]하고, [구체적인 복제 로직]은 [하위 클래스]에서 구현


## 4. 목적 - 3
- 객체 생성 비용 절감
  - 복잡한 초기화 과정을 반복하지 않고, 기존 객체를 복제하여 성능 최적화
- 캡슐화 유지
  - [객체의 복제 로직] 을 캡슐화하여, 클라이언트가 객체의 내부 상태를 알 필요 없음


# 04.  패턴이 적합한 상황과 선택의 이유를 다른 패턴과 비교하며 학습


## 1. 적용 조건
- 이 패턴이 적합한 상황은 언제인가요?
- 적용하기 위한 전제 조건이나 특정 문제 유형을 설명하세요.

## 2. 비교와 선택
- 이 패턴을 다른 유사한 패턴과 비교하세요.
  - 예: Factory Method와 Abstract Factory의 차이.
- 어떤 상황에서 이 패턴을 선택해야 하는지 설명하세요.


## 3. 관련된 패턴
- 이 패턴과 함께 자주 사용되는 패턴은 무엇인가요?
  - 예: Decorator 패턴은 Strategy 패턴과 함께 사용되기도 함.
- 다른 패턴과의 관계를 설명하세요.
  - 예: 이 패턴이 다른 패턴의 일부로 사용되거나, 서로 보완적 역할을 하는 경우.


# 04.  패턴을 실제로 사용할 때 발생할 수 있는 문제와 실전 사례

## 1. 오해와 주의점
- 이 패턴과 관련된 일반적인 오해는 무엇인가요?
  - 예: Singleton은 무조건 하나의 인스턴스만 생성된다는 오해.
- 패턴을 잘못 사용할 때 발생할 수 있는 문제를 설명하세요.
  - 예: 잘못된 Singleton 구현은 멀티스레드 환경에서 동기화 문제를 유발.



## 2. 프로젝트 경험
- 이 패턴을 실제 프로젝트에서 사용한 경험이 있나요?
- 사용했던 사례와 그 결과를 기록하세요.
  - 프로젝트 이름, 패턴 적용 이유, 결과 등.



## 3. 확장성
- 이 패턴을 확장하거나 변형하는 방법은 무엇인가요?
  - 예: Prototype 패턴에서 깊은 복사와 얕은 복사를 선택적으로 구현.
- 확장 가능한 구조로 설계하기 위한 팁이나 예시를 작성하세요.



## 4. 비용
- 이 패턴을 사용하는 데 드는 비용(성능, 코드 복잡도 등)을 분석하세요.
  - 예: Decorator는 클래스 수가 증가하여 코드가 복잡해질 수 있음.
- 효율적으로 사용할 수 있는 방법을 설명하세요.
  - 예: 필요 이상의 Decorator를 사용하지 않고 핵심 기능에만 적용.